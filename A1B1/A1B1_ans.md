# A1 & B1: Setting up and Networking tools

## 1. VirtualBox virtual machines

### 1.1 Create yourself a key-pair to be used with the virtual machines. See ssh-keygen(1) for help.

See the scripts in the `scripts` directory for more.

## 2. Networking basics

### 2.1 Using ip(8), find all the active interfaces on your machine.

Use:

```bash
ip link show up
```

Result:

```bash
ncao@lab1:~$ ip link show up
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000
    link/ether 08:00:27:7b:65:90 brd ff:ff:ff:ff:ff:ff
3: enp0s8: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000
    link/ether 08:00:27:2b:37:fb brd ff:ff:ff:ff:ff:ff
4: enp0s9: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP mode DEFAULT group default qlen 1000
    link/ether 08:00:27:1f:da:ac brd ff:ff:ff:ff:ff:ff
```

### 2.2 Using netstat(8) and arp(8), find the MAC address of the default router of your machine.

Use:

```bash
ncao@lab1:~$ ip route show default
default via 10.0.2.1 dev enp0s3 proto dhcp src 10.0.2.14 metric 100
```

Result:

```bash
ncao@lab1:~$ arp -n 10.0.2.1
Address                  HWtype  HWaddress           Flags Mask            Iface
10.0.2.1                 ether   52:54:00:12:35:00   C                     enp0s3
```

### 2.3 From resolv.conf(5), find the default name servers and the internet domain of your machine. How is this file generated?

This file is automatically generated and managed by systemd-resolved. This is a dynamic resolv.conf file for connecting local clients to the internal DNS stub resolver of systemd-resolved. This file lists all configured search domains

Use:

```bash
ncao@lab1:~$ cat /etc/resolv.conf | grep nameserver
nameserver 127.0.0.53
```

This file is automatically generated and managed by systemd-resolved. This is a dynamic resolv.conf file for connecting local clients to the internal DNS stub resolver of systemd-resolved. This file lists all configured search domains.

### 2.4 Using dig(1), find the responsible name servers for the cs.hut.fi domain.

Use:

```bash
dig cs.hut.fi +short NS
```

Result:

```bash
ncao@lab1:~$ dig +short NS cs.hut.fi
ns.niksula.hut.fi.
sauna.cs.hut.fi.
```

### 2.5 Using dig(1), find the responsible mail exchange servers for cs.hut.fi domain.

Use:

```bash
ncao@lab1:~$ dig cs.hut.fi +short MX
1 mail.cs.hut.fi.
```

### 2.6 Using ping(8), send 5 packets to aalto.fi and find out the average latency. Try then pinging Auckland University of Technology, aut.ac.nz, and see if the latency is different.

Result:

```bash
ncao@lab1:~$ ping -c 5 aalto.fi
PING aalto.fi (104.17.221.22) 56(84) bytes of data.
64 bytes from 104.17.221.22 (104.17.221.22): icmp_seq=1 ttl=55 time=27.9 ms
64 bytes from 104.17.221.22 (104.17.221.22): icmp_seq=2 ttl=55 time=42.1 ms
64 bytes from 104.17.221.22 (104.17.221.22): icmp_seq=3 ttl=55 time=16.8 ms
64 bytes from 104.17.221.22 (104.17.221.22): icmp_seq=4 ttl=55 time=18.1 ms
64 bytes from 104.17.221.22 (104.17.221.22): icmp_seq=5 ttl=55 time=209 ms

--- aalto.fi ping statistics ---
5 packets transmitted, 5 received, 0% packet loss, time 17016ms
rtt min/avg/max/mdev = 16.836/62.710/208.631/73.520 ms
```

```bash
ping -c 5 aut.ac.nz
PING aut.ac.nz (156.62.238.90) 56(84) bytes of data.
64 bytes from bax.aut.ac.nz (156.62.238.90): icmp_seq=1 ttl=38 time=323 ms
64 bytes from bax.aut.ac.nz (156.62.238.90): icmp_seq=2 ttl=38 time=310 ms
64 bytes from bax.aut.ac.nz (156.62.238.90): icmp_seq=3 ttl=38 time=572 ms
64 bytes from bax.aut.ac.nz (156.62.238.90): icmp_seq=4 ttl=38 time=593 ms
64 bytes from bax.aut.ac.nz (156.62.238.90): icmp_seq=5 ttl=38 time=512 ms

--- aut.ac.nz ping statistics ---
5 packets transmitted, 5 received, 0% packet loss, time 4000ms
rtt min/avg/max/mdev = 310.319/461.818/592.599/121.683 ms
```

The average latency for aalto.fi is 10.836 ms and for aut.ac.nz is 310.319 ms.

### 2.7 Using traceroute(1), find out how many hops away is amazon.com. Why does this address sometimes produce different results on different traceroute runs?

Use:

```bash
traceroute -I amazon.com -m 40
```

Result:

```bash
ncao@lab1:~$ traceroute -I amazon.com -m 40
traceroute to amazon.com (52.94.236.248), 40 hops max, 60 byte packets
 1  _gateway (10.0.2.1)  0.687 ms  0.381 ms  0.273 ms
 2  192.168.0.1 (192.168.0.1)  2.557 ms  2.259 ms  1.832 ms
 3  gw-1-v302.kyla.fi (82.130.9.252)  3.134 ms  3.084 ms  2.834 ms
 4  funet-espoo1-100g-r1.ayy.fi (82.130.63.245)  3.070 ms  2.757 ms  2.532 ms
 5  fi-csc.nordu.net (109.105.102.168)  5.980 ms  6.014 ms  5.808 ms
 6  de-hmb.nordu.net (109.105.97.77)  19.218 ms  25.042 ms  25.201 ms
 7  nl-ams.nordu.net (109.105.97.80)  26.401 ms  26.123 ms  25.852 ms
 8  us-man.nordu.net (109.105.97.64)  126.583 ms  112.602 ms  112.136 ms
 9  nyiix-peering.amazon.com (198.32.160.64)  112.004 ms  111.669 ms  111.401 ms
10  150.222.68.84 (150.222.68.84)  111.148 ms  114.422 ms  114.096 ms
11  150.222.68.85 (150.222.68.85)  120.833 ms  131.576 ms  122.731 ms
12  * * *
13  150.222.68.64 (150.222.68.64)  108.647 ms  112.423 ms  115.064 ms
14  * * *
15  * * *
16  * * *
17  * * *
18  * * *
19  * * *
20  * * *
21  * * *
22  * * *
23  * * *
24  52.94.236.248 (52.94.236.248)  116.586 ms  116.066 ms  118.107 ms
```

```bash
# Second run
traceroute -I amazon.com -m 40
traceroute to amazon.com (205.251.242.103), 40 hops max, 60 byte packets
 1  _gateway (10.0.2.1)  0.848 ms  0.527 ms  1.054 ms
 2  192.168.0.1 (192.168.0.1)  5.335 ms  5.057 ms  4.713 ms
 3  gw-1-v302.kyla.fi (82.130.9.252)  5.090 ms  6.468 ms  5.908 ms
 4  funet-espoo1-100g-r1.ayy.fi (82.130.63.245)  8.257 ms  7.880 ms  7.428 ms
 5  fi-csc.nordu.net (109.105.102.168)  6.228 ms  5.965 ms  5.414 ms
 6  de-hmb.nordu.net (109.105.97.77)  29.827 ms  33.984 ms  32.139 ms
 7  nl-ams.nordu.net (109.105.97.80)  31.914 ms  30.887 ms  30.265 ms
 8  us-man.nordu.net (109.105.97.64)  109.082 ms  112.203 ms  111.954 ms
 9  nyiix-peering.amazon.com (198.32.160.64)  111.892 ms  111.670 ms  111.425 ms
10  150.222.68.88 (150.222.68.88)  120.226 ms  119.409 ms  119.133 ms
11  150.222.68.91 (150.222.68.91)  125.644 ms  124.552 ms  112.270 ms
12  * * *
13  150.222.68.78 (150.222.68.78)  112.768 ms  110.754 ms  111.552 ms
14  * * *
15  * * *
16  * * *
17  * * *
18  * * *
19  * * *
20  * * *
21  * * *
22  * * *
23  * * *
24  s3-console-us-standard.console.aws.amazon.com (205.251.242.103)  330.933 ms  329.488 ms  327.587 ms
```

Results may vary across runs due to dynamic network conditions, load balancing, firewall policies, and routing changes. Internet traffic is influenced by these factors, leading to different paths for packets on different traceroute runs.
Because of congestion differences for each run and the Internet tries to choose the best routing option for us.

### 2.8 Using mtr(8) find out the minimum, maximum and average network latency between your machine and google.com Can the packet loss %age > 0 even if there is no loss in transport layer traffic? Why?

- The mtr command is used for network diagnostics and combines the functionality of the ping and traceroute utilities.
  Use:

Result:

```bash
ncao@lab1:~$ mtr --report google.com
Start: 2024-01-15T20:01:12+0000
HOST: lab1                        Loss%   Snt   Last   Avg  Best  Wrst StDev
  1.|-- _gateway                   0.0%    10    2.1   1.2   0.9   2.1   0.4
  2.|-- 192.168.0.1                0.0%    10   35.5  57.4   3.0 243.5  90.4
  3.|-- gw-1-v302.kyla.fi          0.0%    10   19.1  68.9   3.0 187.2  76.1
  4.|-- funet-espoo1-100g-r1.ayy.  0.0%    10    4.9  24.9   3.7  96.2  31.1
  5.|-- fi-csc.nordu.net           0.0%    10    3.4  18.9   3.4 114.1  34.0
  6.|-- se-tug.nordu.net           0.0%    10  181.3  34.7  14.1 181.3  51.8
  7.|-- se-kst2.nordu.net          0.0%    10   89.8  81.6  13.7 338.6 123.1
  8.|-- 72.14.196.42               0.0%    10   16.7  80.1  14.7 251.1 100.2
  9.|-- 142.250.214.171            0.0%    10   24.8  67.3  14.9 175.7  66.1
 10.|-- 142.251.236.73             0.0%    10   19.7  26.3  15.3  84.3  22.1
 11.|-- arn11s12-in-f14.1e100.net  0.0%    10  237.6  38.5  14.3 237.6  70.0

```

- "mtr" may show packet loss (percentage greater than 0) because certain network devices, like routers or firewalls, may treat the diagnostic packets differently than your normal internet traffic, leading to apparent loss in the tool even when your actual data traffic is okay.

- If the destination host (or any router along the route) is configured to drop ICMP packets in its firewall rules (configured using iptables or other firewall management tools), it will not respond to ICMP requests. As a result, tools like ping or mtr may show packet loss or lack of response for that specific hop, even if the overall data traffic is not affected

## 3. Using nmap(1) to scan networks.

### 3.1 Using nmap(1) to scan your local network, and show the list of all live and up hosts and open ports on VMs.

Due to shortness of time, I will limit the range of the IP address for nmap to scan

Result:

```bash
sudo nmap -sT -p- 10.0.2.0-20
Starting Nmap 7.80 ( https://nmap.org ) at 2024-01-16 17:48 UTC
Strange read error from 10.0.2.2 (104 - 'Connection reset by peer')
Stats: 0:01:03 elapsed; 11 hosts completed (4 up), 4 undergoing Connect Scan
Connect Scan Timing: About 52.76% done; ETC: 17:50 (0:00:56 remaining)
Nmap scan report for _gateway (10.0.2.1)
Host is up (0.0087s latency).
Not shown: 65534 closed ports
PORT   STATE SERVICE
53/tcp open  domain
MAC Address: 52:54:00:12:35:00 (QEMU virtual NIC)

Nmap scan report for 10.0.2.2
Host is up (0.0027s latency).
Not shown: 65517 closed ports
PORT      STATE SERVICE
22/tcp    open  ssh
53/tcp    open  domain
5000/tcp  open  upnp
7000/tcp  open  afs3-fileserver
7335/tcp  open  swx
10001/tcp open  scp-config
10002/tcp open  documentum
10003/tcp open  documentum_s
15292/tcp open  unknown
15393/tcp open  unknown
16494/tcp open  unknown
18412/tcp open  unknown
27017/tcp open  mongod
29754/tcp open  unknown
44950/tcp open  unknown
44960/tcp open  unknown
49168/tcp open  unknown
54916/tcp open  unknown
MAC Address: 52:54:00:12:35:00 (QEMU virtual NIC)

Nmap scan report for 10.0.2.3
Host is up (0.0078s latency).
All 65535 scanned ports on 10.0.2.3 are filtered
MAC Address: 08:00:27:45:B8:AA (Oracle VirtualBox virtual NIC)

Nmap scan report for 10.0.2.15
Host is up (0.011s latency).
Not shown: 65534 closed ports
PORT   STATE SERVICE
22/tcp open  ssh
MAC Address: 08:00:27:FE:D4:B4 (Oracle VirtualBox virtual NIC)

Nmap scan report for 10.0.2.16
Host is up (0.0081s latency).
Not shown: 65534 closed ports
PORT   STATE SERVICE
22/tcp open  ssh
MAC Address: 08:00:27:C2:83:E3 (Oracle VirtualBox virtual NIC)

Nmap scan report for lab1 (10.0.2.14)
Host is up (0.000080s latency).
Not shown: 65534 closed ports
PORT   STATE SERVICE
22/tcp open  ssh

Nmap done: 21 IP addresses (6 hosts up) scanned in 195.52 seconds
```

## 4. Examining the request and response messages of clients and servers using netcat

### 4.1 Using netcat, nc(1), capture the version number of the ssh daemon running on your machine.

Result:

```bash
ncao@lab1:~$ nc 127.0.0.1 22
SSH-2.0-OpenSSH_8.9p1 Ubuntu-3ubuntu0.6
```

### 4.2 Using netcat, nc(1), craft a valid HTTP/1.1 request for getting HTTP headers (not the html file itself) from the front page of www.aalto.fi. What request method did you use? Which headers did you need to send to the server? What was the status code for the request? Which headers did the server return? Explain the purpose of each header.

Use:

```bash
nc www.aalto.fi 80 <<EOL
GET / HTTP/1.1
Host: www.aalto.fi
Connection: close

EOL
```

Result:

```bash
ncao@lab1:~$ echo -e "HEAD / HTTP/1.1\r\nHost: www.aalto.fi\r\nConnection: close\r\n\r\n" | nc www.aalto.fi 80

HTTP/1.1 301 Moved Permanently
Date: Tue, 16 Jan 2024 17:58:12 GMT
Connection: close
Cache-Control: max-age=3600
Expires: Tue, 16 Jan 2024 18:58:12 GMT
Location: https://www.aalto.fi/fi
Server: cloudflare
CF-RAY: 84683ecacf11376b-HEL

```

The netcat command sends an HTTP request with the method "HEAD", which is a type of HTTP request method that asks the server to provide only the headers and not the actual content or body of the response. The purpose of a "HEAD" request is to retrieve metadata about the resource, such as status information and headers, without transferring the entire data payload.

The HTTP response reveals a "301 Moved Permanently" status code, indicating a permanent redirection of the requested resource. The server, identified as Cloudflare, specifies the current date and time in the "Date" header and signals a connection closure after delivering the response. Cache directives include "Cache-Control: max-age=3600," suggesting a maximum caching duration of one hour, and "Expires: Tue, 16 Jan 2024 18:58:12 GMT," indicating when the response should be considered stale. The "Location" header provides the new permanent location of the resource, guiding the client to "https://www.aalto.fi/fi." Additionally, the unique identifier "CF-RAY: 84683ecacf11376b-HEL" offers tracking information generated by the Cloudflare infrastructure, including the data center code "HEL."

### 4.3 Using netcat, nc(1), start a bogus web server listening on the loopback interface port 8080. Verify with netstat(8), that the server really is listening where it should be. Direct your browser lynx(1) to the bogus server and capture the User-Agent: header.

Use:

```bash
nc -lk -p 8080
lynx 127.0.0.1:8080
```

Result:

```bash
vagrant@lab1:~$ nc -l 8080
GET / HTTP/1.0
Host: 127.0.0.1:8080
Accept: text/html, text/plain, text/sgml, text/css, */*;q=0.01
Accept-Encoding: gzip, compress, bzip2
Accept-Language: en
User-Agent: Lynx/2.9.0dev.10 libwww-FM/2.14 SSL-MM/1.4.1 GNUTLS/3.7.1
```

### 4.4 With similar setup to 3.3, start up a bogus ssh server with nc and try to connect to it with ssh(1). Copy-paste the server version string you captured in 3.1 and see if you get a response from the client. What is the client trying to negotiate?

Use:

```bash
nc -l 8080
ssh -p 8080 127.0.0.1
```

Result:

```bash
vagrant@lab1:~$ nc -l 8080
SSH-2.0-OpenSSH_8.9p1 Ubuntu-3
SSH-2.0-OpenSSH_8.9p1 Ubuntu-3
�΄�Dg|
      ���`ň=gcurve25519-sha256,curve25519-sha256@libssh.org,ecdh-sha2-nistp256,ecdh-sha2-nistp384,ecdh-sha2-nistp521,sntrup761x25519-sha512@openssh.com,diffie-hellman-group-exchange-sha256,diffie-hellman-group16-sha512,diffie-hellman-group18-sha512,diffie-hellman-group14-sha256,ext-info-c�ssh-ed25519-cert-v01@openssh.com,ecdsa-sha2-nistp256-cert-v01@openssh.com,ecdsa-sha2-nistp384-cert-v01@openssh.com,ecdsa-sha2-nistp521-cert-v01@openssh.com,sk-ssh-ed25519-cert-v01@openssh.com,sk-ecdsa-sha2-nistp256-cert-v01@openssh.com,rsa-sha2-512-cert-v01@openssh.com,rsa-sha2-256-cert-v01@openssh.com,ssh-ed25519,ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521,sk-ssh-ed25519@openssh.com,sk-ecdsa-sha2-nistp256@openssh.com,rsa-sha2-512,rsa-sha2-256lchacha20-poly1305@openssh.com,aes128-ctr,aes192-ctr,aes256-ctr,aes128-gcm@openssh.com,aes256-gcm@openssh.comlchacha20-poly1305@openssh.com,aes128-ctr,aes192-ctr,aes256-ctr,aes128-gcm@openssh.com,aes256-gcm@openssh.com�umac-64-etm@openssh.com,umac-128-etm@openssh.com,hmac-sha2-256-etm@openssh.com,hmac-sha2-512-etm@openssh.com,hmac-sha1-etm@openssh.com,umac-64@openssh.com,umac-128@openssh.com,hmac-sha2-256,hmac-sha2-512,hmac-sha1�umac-64-etm@openssh.com,umac-128-etm@openssh.com,hmac-sha2-256-etm@openssh.com,hmac-sha2-512-etm@openssh.com,hmac-sha1-etm@openssh.com,umac-64@openssh.com,umac-128@openssh.com,hmac-sha2-256,hmac-sha2-512,hmac-sha1�none,zlib@openssh.com,zlib�none,zlib@openssh.com,zlib
```

Ihe client is trying to negotiate the encryption algorithm.

## 5. Vagrant

### 5.1 Which providers does vagrant support?What does command: \<vagrant init\> do?

https://developer.hashicorp.com/vagrant/docs/providers

Vagrant ships out of the box with support for VirtualBox, Hyper-V, and Docker, Vagrant has the ability to manage other types of machines as well. This is done by using other providers with Vagrant.

Alternate providers can offer different features that make more sense in your use case. For example, if you are using Vagrant for any real work, VMware providers are recommended since they're well supported and generally more stable and performant than VirtualBox.

https://developer.hashicorp.com/vagrant/docs/cli/init

This initializes the current directory to be a Vagrant environment by creating an initial Vagrantfile if one does not already exist.

### 5.2 What is box in Vagrant? How to add a box to the vagrant environment?

https://developer.hashicorp.com/vagrant/docs/boxes

Boxes are the package format for Vagrant environments. You specify a box environment and operating configurations in your Vagrantfile. You can use a box on any supported platform to bring up identical working environments.

You can add a box from the public catalog at any time. The box's description includes instructions on how to add it to an existing Vagrantfile or initiate it as a new environment on the command-line.

https://developer.hashicorp.com/vagrant/docs/boxes/base

### 5.3 Show the provisioning part of your sample code and explain it?

See comments in Vagrantfile.

### 5.4 Upload a file from your host to a vm? Share a folder on your host to a vm.

Use:

```bash
# vagrant plugin install vagrant-scp
scp -P 10002 dummy.sh  ncao@127.0.0.1:~/
```

https://developer.hashicorp.com/vagrant/docs/synced-folders
https://developer.hashicorp.com/vagrant/docs/synced-folders/basic_usage

### 5.5 Show the running boxes in your provider via ssh?

Use:

```bash
vagrant box list
VBoxManage list runningvms
```

Result:

```bash
vagrant box list
```

# 5. Vagrant

## 5.1 Providers and init

By default, Vagrant supports VirtualBox, VMWare, Docker, Hyper-V, and they have instructions on setting up functionality with custom providers.

The vagrant init command is used to automatically generate a boilerplate Vagrantfile with setup for the default box and comments to help guide the user to relevant portions of the documentation for certain functionality. To specify a different box, use vagrant init box_identifier.

## 5.2 Boxes

Boxes in vagrant are similar to the contept of containers in Docker. They provide different base setups which can be modified to add custom functionality using the Vagrantfile. The box used in this exercise was ubuntu/jammy64 which includes the full setup, user creation, network setup process by default. The Vagrantfile was used to specific custom network settings and startup scripting.

To add a box to the vagrant environment, there are steps available [here](https://developer.hashicorp.com/vagrant/docs/boxes/base). Essentially, there is some setup process automating the base setup using some agreed upon default values. This creates a .box file and you then create a JSON file with some meta info as well. The box can then be hosted in a private repository or on a public hub such as [HashiCorp's Vagrant Cloud](https://developer.hashicorp.com/vagrant/vagrant-cloud). The box is added using vagrant box add --name my-box /path/to/the/new.box.

## 5.3 Provisioning

The setup includes basic provisioning. The shared provisioning updates apt packages, installs net-tools, and adds the public ssh key to the authorized_keys file. Each machine then has provisioning to add ip hostname shortcuts. For example, lab2 and lab3 each establish a hostname binding of lab1 with its respective ip for their subnet. This makes it easier to communicate between machines without having to think about which subnet / ip to use.

## 5.4 Shared Files

My current vagrant setup supports a synced folder "scripts" with all the machines.

To send a specific file you can use scp -P vagrant_port /path/to/local/file vagrant@127.0.0.1:/path/on/guest

## 5.5 Connect to running boxes over ssh

Boxes can be reached using ssh vagrant@localhost -p 1000x where x is 1,2,3. Alternatively, adding the -A flag allows you to ssh using agents. Then from within lab1 for example, you can run ssh lab2 to connect to lab2 using the passthrough private key.

```

```
